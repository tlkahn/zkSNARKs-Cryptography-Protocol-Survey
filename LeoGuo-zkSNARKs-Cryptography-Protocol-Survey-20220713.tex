% Created 2022-07-13 Wed 01:21
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[backend=biber, natbib=true, style=alphabetic, sorting=ynt]{biblatex}
\addbibresource{/Users/toeinriver/Dropbox/emacs/bibliography/references.bib}
\author{Leo Guo}
\date{\today}
\title{zkSNARKs Cryptography Protocol Survey}
\hypersetup{
 pdfauthor={Leo Guo},
 pdftitle={zkSNARKs Cryptography Protocol Survey},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 29.0.50 (Org mode 9.5.1)},
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents


\section{zkSNARKs Cryptography Protocol Survey}
\label{sec:org36784af}
\subsection{Basic information}
\label{sec:org78f249f}
\begin{center}
\begin{tabular}{ll}
\hline
Item & zkSNARKs Cryptography Protocol Survey\\
Name & Leo Guo\\
Discord Account & toeinriver7694\\
Study Group & team3\\
Assignment & zkSNARKs Cryptography Protocol Survey\\
GitHub & \url{https://github.com/tlkahn/zkSNARKs-Cryptography-Protocol-Survey}\\
\end{tabular}
\end{center}

\subsection{Introduction}
\label{sec:org05183bd}
\subsubsection{Overview}
\label{sec:orgca4d5b9}
zkSNARK is one of the most important Zero-Knowledge Proof (ZKP) methods used in privacy computing and blockchain technology. zkSNARK stands for: zero-knowledge Succinct Non-Interactive ARgument of Knowledge, which is a protocol through which a prover can quickly convince a verifier on knowledge of a secret without revealing anything about it. Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer introduced the term zk-SNARKs in 2012 \cite{2012}
The core theoritecal components of zkSNARK are summarized below:
\begin{itemize}
\item zero-knowledge (zk)
According to Goldwasser, Micali, and Rackoff \cite{1985}, who first introduced the "zero-knowledge” concept as "\emph{Zero-knowledge proofs are defined as those proofs that convey no additional knowledge other than the correctness of the proposition in question}". There are three essential attributes of zk featuring protocols:
\begin{itemize}
\item Completeness: If the statement is true, then the verifier always accepts the proof \(\pi\).
\item Soundness: If the statement is false, then the prover can only convince the verifier with a negligible probability.
\item Zero-knowledge: a correct proof \(\pi\) does not leak any information about the secret.
\end{itemize}
\item Succictness (S)
The first constructions of SNARK protocols were inspired by the PCP theorem \cite{10.1145/273865.273901} which shows that NP statements have "short" Probabilistic Checkable Proofs (PCP). New instantiations were found which allow faster and shorter proofs, when a preprocessing state is permitted. With proper pre-processing and arithematization, the proof becomes realistically feasible w.r.t proof size, running time, verification time etc. The formal definition is below \cite{2012}:

\begin{quote}
The length of the proof \(\Pi\) that \(\mathcal{P}(y,w,vgrs)\) outputs, as well as the running time of \(\mathrm{nu}(priv, y, \Pi)\), is bounded by:

\[
  p(k+\lvert y \rvert) = p(k + \lvert M \rvert + \lvert x \rvert + log t)
  \]

where \(p\) is a universal polynomial that does not depend on \(\mathcal{R} \subseteq \mathcal{R}_\mathcal{U}\). \(\mathcal{R}_\mathcal{U}\) is the universal relation \cite{10.5555/872747.873184}, a.k.a the set \(\mathcal{R}_\mathcal{U}\) of instance-witness pairs \((y, w)\), where \(y=(M, x, t), \lvert w \rvert \le t\) and \(M\) is a Turing machine such that M accepts \((x,w)\) after at most \(t\) steps.
\end{quote}

\item "Non-interactive" (N) means the prover can publish a single one-way message to the verifiers, with no need of further back-and-forth interactions.
\item "ARguments" (AR) means the verifier is only protected against computationally limited provers. Provers with computationally unlimitted power can fake proofs/arguments on wrong statements (with enough computational power, any public-key encryption can be broken). This is also called “computational soundness”, as opposed to “perfect soundness”. \footnote{Christian Reitwiessner's blog: \href{https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/}{zkSNARKs in a nutshell}\label{orgcec628f}}
\item "of Knowledge":

SNARKs are SNARGs where computational soundness is replaced by knowledge soundness, which roughly means the prover is not able to construct a proof without knowing the witness \(w\). \textsuperscript{\ref{orgcec628f}}
\end{itemize}

\subsubsection{Big idea}
\label{sec:orgca6c4f5}
As the name hints, zkSNARKs have four main components \textsuperscript{\ref{orgcec628f}}:

\begin{itemize}
\item Encoding the problem as a polynomial

The problems are compiled into polynomials, e.g. \(t(x)h(x) = w(x)v(x)\), the Quadratic Span Programs (QSP) as in \cite{10.1007/978-3-642-38348-9_37}, where the equality holds \emph{iff} the program is computed correctly. The prover convinces the verifier that the above equality holds. The formal definition in \cite{2012} is:

\begin{quote}
\ldots{} membership of an instance \(y\) in an \(NP\) language \(L\) can be verified in time that is bounded by \(p(k, \lvert y \rvert, \log t)\), where \(t\) is the time to evaluate the \(NP\) verification relation for \(L\) on input \(y\), \textbf{\(p\) is a fixed polynomial independent of \(L\)}, and \(k\) is a security parameter that determines the soundness error.
\end{quote}

In general, zkSNARKs can be contructed from four categories \cite{Nitulescu2020zkSNARKsAG}:

\begin{itemize}
\item PCP

The oldest SNARK construction methodology is explained:

\begin{quote}
\ldots{}is based on PCP characterization of NP, and it is first achieved in the random oracle model (ROM), which gave only heuristical security. The idea is to apply the random oracle-based Fiat-Shamir transform to Kilian’s succinct PCP-based proof system [Kil92], achieving logarithmic proof size and verification time. Later, the construction is improved by removing the use of the random oracles and replacing them with extractable collision-resistant hash functions (ECRH).

The work of [CL08] proposed the PCP + Merkle Tree (MT)+ Private Information Retrieval (PIR) approach to “squash” Kilian’s four-message protocol into a two-message protocol.

In both cases, we do not obtain knowledge soundness, but only plain adaptive soundness.
\end{quote}

\item QAP

The most popular and widely implemented SNARK construction shares a central starting point on quadratic programs introduced by \cite{10.1007/978-3-642-38348-9_37}. The proof/verification framework build SNARKs for programs encoded as boolean or arithmetic circuits.

\begin{quote}
\emph{Arithmetic Circuits}: Informally, an arithmetic circuit consists of wires that carry values from a field F and connect to addition and multiplication gates.

\emph{Boolean Circuits}: A boolean circuit consists of logical gates and of a set of wires between the gates. The wires carry values over \{0, 1\}.
\end{quote}

This approach has led to fast progress towards practical verifiable computations. The first implementation is Pinocchio \cite{6547113}.

\begin{quote}
A SNARK scheme for a circuit has to enable verification of proofs for (Arithmetic or Boolean) Circ-SAT problem, i.e., a prover, given a circuit (\(\mathcal{C}\)) has to convince the verifier that it knows an assignment of its inputs that makes the output true.
\end{quote}

Circ-SAT problem is the NP-complete decision problem of determining whether a given circuit has an assignment of its inputs that makes the output true. A very important line of works focuses on building SNARKs for circuit satisfiability and have as a central starting point the framework based on quadratic span programs (QSP) \cite{10.1007/978-3-642-38348-9_37}. QSP consists of multiple polynomials \(\nu_0, \dots, \nu_i; \omega_0, \dots, \omega_i\) over a Galois field \(F\) and a target polynomial \(t\). The QSP is accepted \emph{iff} \(t\) divides \(\nu_a \times \omega_b\) where \(nu_a\) and \(\omega_b\) is constructed from the witness \(w\) and the original polynomials \(\nu_0, \dots, \nu_i; \omega_0, \dots, \omega_i\).

Further more, QSP can be improved by QAP. \cite{Nitulescu2020zkSNARKsAG}

\begin{quote}
Parno eta. \cite{6547113} defined QAP,a similar notion for arithmetic circuits,namely Quadratic Arithmetic Programs (QAP). More recently, an improved version for boolean circuits, the Square Span Programs (SSP) was presented which consequentially has led to a simplified version for arithmetic circuits, Square Arithmetic Programs (SAP), proposed in \cite{10.1007/978-3-319-63715-0_20}.
\end{quote}

\item Linear Interactive Proof (LIP)

According to \cite{Nitulescu2020zkSNARKsAG},

\begin{quote}
The QAP approach was generalized under the concept of Linear Interactive Proof (LIP), a form of interactive ZK proofs where security holds under the assumption that the prover is restricted to compute only linear combinations of its inputs.

These proofs can then be turned into (designated-verifier) SNARKs by using an extractable linear-only encryption scheme.
\end{quote}

\item Polynomial Interactive Oracle Proof (PIOP)

According to \cite{Nitulescu2020zkSNARKsAG}:

\begin{quote}
As we saw previously, SNARKs are commonly build in a modular way. Recent works propose schemes that follow a new framework, enabling more possibilities such as: \textbf{transparent constructions (without a trusted setup), recursion, aggregation properties, post-quantum security}, etc.

Modular instantiations of recent SNARKs employs polynomial \emph{interactive oracle proofs (IOP)} for the information theoretic step, and \emph{polynomial commitments} for the cryptographic compilation. One advantage of using polynomial commitments is that \textbf{the setup is only needed for the commitment scheme and is thus independent of the statement being proven.} This allows these SNARKs to be \textbf{universal} as opposed to the circuit-based SNARKs presented in the previous section. Another advantage is that the choice of polynomial commitment scheme facilitates finding the right tradeoff between performance and security.

To build such SNARKs, one commonly follows 3 steps:

\begin{itemize}
\item NP Characterization or Arithmetisation for Circuits:

Start with a way to describe the computation to be proven as a system of constraints involving native operations over a finite field. Then, this system of constraints can be changed into a (low-degree) \textbf{univariate polynomial expression}.

\item Polynomial IOP or Algebraic Holographic Proofs:

The proof consists in finding a way to show that such a polynomial equation holds. In a Polynomial Interactive Oracle Proof (PIOP), the prover sends low degree polynomials to the verifier, and rather than reading the entire list of coefficients, the verifier queries evaluations of these polynomials in a random point to an oracle interface.

\item Cryptographic Compiler.

Using polynomial commitment schemes and Fiat-Shamir heuristic, the previous checks can be compiled into an efficient and non-interactive proof system. The resulting zk-SNARK has either universal updatable structured reference string (SRS), or transparent setup, depending only on the nature of the polynomial commitment scheme used in this step.

Remark that the only step where we employ cryptographic techniques is the final one. In this cryp- tographic compilation step the oracles from before are replaced by a suitable cryptographic realization: Polynomial Commitments (PC) in Sonic, Marlin and Plonk (\cite{inproceedings}, \cite{inproceedings}, \cite{Gabizon2019PLONKPO}). \footnote{The computation of polynomial commitment can be optimized by table lookup. \cite{Gabizon2020plookupAS}} Polynomial commitments allow to check efficiently a series of identities on low-degree polynomials resulting from the arithmetization step. This comes at the expense of introducing computational hardness assumptions for security and sometimes a trusted setup.
\end{itemize}
\end{quote}

A typical modern zkSNARK process can be illustrated as follows:

\begin{figure}[htbp]
\centering
\includegraphics[width=.9\linewidth]{./snark-process.png}
\caption{Source: unknown, but appears to be frequently credited to cryptographer Eran Tromer.}
\end{figure}

Polynomial commitments e.g. KZG, are a commitment scheme introduced by \cite{Kate} which are extremely powerful constructs that allow a prover to commit a polynomial and show evaluations of that polynomial on any point with a single group element-sized proof in constant time. As such, Kate commitments and its variants lie at the heart of many PIOP-style zkSNARK constructions (such as Marlin and PLONK).
\end{itemize}

\item Succictness by random sampling

The verifier randomly samples a secret input \(s\) for evaluation with the polynomials, thus reducing the problem from polynomials operations to simple evaluation on numbers, e.g. \(t(s) h(s) = w(s) v(s)\)

\item Homomorphic encoding/encryption

An encoding/encryption function \(e\) is used that has some homomorphic properties. Combining the research on pairing-based double homomorphic encryption scheme \cite{10.1007/978-3-540-30576-7_18} and NIZK leads to the solution on uncondictional zero-knowledge:

\begin{longtable}{|p{2cm}|l|l|}
\hline
ZK proof for NP-complete languages & Computational zero knowledge & Unconditional zero knowledge\\
\hline
\endfirsthead
\multicolumn{3}{l}{Continued from previous page} \\
\hline

ZK proof for NP-complete languages & Computational zero knowledge & Unconditional zero knowledge \\

\hline
\endhead
\hline\multicolumn{3}{r}{Continued on next page} \\
\endfoot
\endlastfoot
\hline
Interactive & Goldreich-Wigderson-Micali 1986 & Brassard-Crépeau 1986\\
\hline
Non-interactive & Blum-Feldman-Micali 1988 & Groth-Ostrovsky-Sahai 2006\\
\hline
\end{longtable}

\begin{itemize}
\item Core idea (\cite{10.1007/11761679_21}) to prove circuit satisfiability with zk \footnote{Jens Groth's lecture \href{https://www.youtube.com/watch?app=desktop\&v=X-z3JYlFdzs\&feature=youtu.be}{Bilinear Pairings-based Zero-Knowledge Proofs}}:

\begin{itemize}
\item Commit to wire values in circuit as \(g^a h^r, g^b h^s, g^c h^t, \dots\)
\item Verifier can easily add committed elements: \(g^a h^r \cdot g^b h^s = g^{a+b} h^{r+s}\)
\item Prover can demonstrate multiplicative relation: \(e(g^a h^r, g^b h^s) = e(g^c h^t, g) e(\pi, h)\)
\end{itemize}
\end{itemize}

\item Obfuscation

The prover obfuscates the values \(e(g^a h^r, g^b h^s), e(g^c h^t, g), e(\pi, h)\) by multiplying with a non-zero secret point \(k\) from the contextual elliptic curve (EC) on both sides, thus the verifier can still verify the correctness on hidden values.
\end{itemize}

\subsection{Overview of research scope}
\label{sec:org9f9d47b}


\subsection{Theortical development}
\label{sec:orgdf6c73d}
\subsubsection{Protocol overview}
\label{sec:org3c3ab39}

\begin{itemize}
\item Pinocchio \footnote{See \href{https://medium.com/coinmonks/comparing-general-purpose-zk-snarks-51ce124c60bd}{Source}}:

\item Groth16:

Currently the fastest and smallest known zk-SNARK. It’s used in Zcash, amongst others. Groth16 is non-universal; the setup is always tied to one specific circuit. Because of the speed and small proof size, performance of new zk-SNARKS is often compared to Groth16.

\begin{itemize}
\item Major features:

\item Design ideas

\item Main contributions
\end{itemize}

\item Sonic:

Sonic is an early general purpose zk-SNARK protocol. The paper was published in January 2019, 10 months before this blog post was written, which is an eternity in zk-SNARK time. Sonic supports a universal and updatable common reference string. Sonic proofs are constant size, but verification is expensive. In theory, multiple proofs can be verified in batches to achieve better performance. Many of the new zk-SNARKs listed below are based on Sonic.

\item Supersonic

We present a generic compilation of any PIOP using our DARK polynomial commitment scheme. In particular, compiling the PIOP from PLONK (GWC, ePrint’19), an improvement on Sonic (MBKM, CCS’19), yields a public-coin interactive argument with quasi-linear preprocessing, quasi-linear (online) prover time, logarithmic communication, and logarithmic (online) verification time in the circuit size. Applying the Fiat-Shamir transform results in a SNARK, which we call Supersonic.

\item Marlin:

Marlin is an improvement on Sonic with 10x better prover time and 4x better verification times.

\item Plonk:

Plonk is an improvement on Sonic with a 5x better prover time.

\item Halo \& Halo2

Halo is a zk-SNARK that supports recursive proof composition without a trusted setup. Recursion works using “nested amortization”: repeatedly collapsing multiple proofs together over cycles of elliptic curves.

Unlike the other new constructs, Halo’s verification time is linear, making it the only new construct that isn’t succinct.

\item Spartan

\item Nova

\item Quarks

\item Woverine

\item Poseiden
\end{itemize}

\subsection{Application development}
\label{sec:orge669a39}

\subsection{Summary}
\label{sec:org3388203}

\subsubsection{Comparative analysis}
\label{sec:orgf11a726}
\begin{center}
\begin{tabular}{lll}
Protocol & Pros & Cons\\
\hline
Pinocchio &  & \\
Groth16 &  & \\
Bulletproof &  & \\
Plonk &  & \\
Halo \& Halo2 &  & \\
\end{tabular}
\end{center}

\subsubsection{Outlook}
\label{sec:org9b8a83a}

\begin{enumerate}
\item Recursive ZK Proofs
\label{sec:orgfe82cc6}

Recursive zero-knowledge SNARKs are one of the most interesting use cases for zero-knowledge technology that are almost ready for practical use. As the name suggests, recursive ZK SNARKs unlock the ability to take a proof and verify it inside another proof, allowing for a lot more composability without blowing up proving/verifying times. Besides the real-world composability advantages, recursive zero-knowledge SNARKs are also of great interest because of their use case as a blockchain scaling solution, relying on the succinct- ness feature of SNARKs to compress secure verification of long blockchains. Mina Protocol ([Bonneau et al. 2020]) is currently implementing such an approach.

It should, however, come as no surprise that efficient recursive ZK SNARK constructions are quite hard to pull off. With the typical method of SNARK constructions that uses elliptic curve fields, the initial, hairy problem to solve is to find a pairing-friendly curve (see [Bitansky et al. 2013a]). Attempting to solve for this yields many interesting tradeoffs. Many of the options and possibilities have been explored in recent works such as Halo [Bowe et al. 2019], which uses elliptic curve cycles that do not require pairings and Fractal [Chiesa et al. 2020b], that eliminates the use of elliptic curves altogether. Overall, the study of efficient recursive ZK proofs is of great importance, and ripe territory for further exploration.


\item Post-Quantum Zero-Knowledge
\label{sec:org1cb6b46}

Many of the techniques described in previous sections depend on the computational hardness of certain problems, such as computing the discrete logarithm, which have been shown solvable by quantum computers in polynomial time by [Shor 1997]. Therefore, quantum computers may pose a significant threat to the security model and practicality of zk-SNARKs that use these techniques. There has been some work on making quantum attack resistant zk-SNARKs. For instance, [Gennaro et al. 2018] recently proposed a lattice-based zk-SNARK starting with SSP — square span programs (an alternative to the QAP intermediate for boolean circuits). Lattice problems are known to hold against quantum attacks [Ajtai 1996], so this is a very promising line of work.


\item Optimizations
\label{sec:orgdc8ef03}

\begin{itemize}
\item Plonk:

\begin{itemize}
\item SHPLONK: multiple commits
\item TurboPLONK: Custom gates (e.g. EC point addition gates, greatly reducing pairing's computation cost)
\item PLOOKUP: SNARK-unfriendly functions
\item Zexe PLONK: PLONK single-layer rollup with BLS12-377 + BW6-761
\end{itemize}

\item Blockchain transaction fee:

FFLONK \cite{cryptoeprint:2021/1167}, a modification of the popular PLONK zk-SNARK scheme, was motivated by ethereum gas fee reduction. Modification to KZG commitments that allows for reducing the scalar multiplications necessary to verify the proof by nearly three times, albeit at the cost of almost tripling proof construction time.
\end{itemize}

\item Fiat-Shamir-Compatible Hash Functions
\label{sec:org8c8bb08}

Currently Fiat-Shamir heuristic's security is only proven in the Random Oracle Model. It remains an open question whether there exist concrete hash functions that are compatible with the Fiat Shamir heuristic, i.e. if there exist hash functions that guarantee soundness for a transformed proof (and are also compatible with zero-knowledge proofs). There has been a lot of work on this topic, but there is still no known universal hash function that can be proven to be compatible without making strong, somewhat impractical, assumptions yet.

\printbibliography
\end{enumerate}
\end{document}